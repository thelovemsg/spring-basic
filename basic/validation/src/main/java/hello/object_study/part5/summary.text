INFORMATION EXPERT(정보 전문가) 패턴
ㄴ 메시지를 전송할 객체는 무엇을 원하는가? 메시지를 수신할 적합한 객체는 누구인가?
ㄴ 책임을 수행항 정보를 알고있는 객체에게 책임을 할당
ㄴ 객체가 자율적인 존재여야 한다는 사실을 다시 한번 상기시킨다.

LOW COUPLING(낮은 결합도) 패턴
ㄴ 어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?
   => 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라!

HIGH COHESION(높은 응집도) 패턴
ㄴ 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가?
   => 높은 응집도를 유지할 수 있게 책임을 할당하라!

CREATOR(생성자) 패턴
ㄴ 객체 A를 생성해야 할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가?
다음 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라.

    1. B가 A객체를 포함하거나 참조한다.
    2. B가 A객체를 기록한다.
    3. B가 A객체를 긴밀하게 사용한다.
    4. B가 A객체를 초기화하는 데 피요한 데이터를 가지고 있다. (이 경우 B는 A에 대한 정보 전문가다.)

PROTECTED VARIATIONS 패턴
ㄴ 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하돌고 책임을 할당하라.
   => 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라.

---- 6장 ----
객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고받는 메시지다.
한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송 또는 메시지 패싱이라고 한다.

메시지는 오퍼레이션명과 인자로 구성. 메시지 전송은 여기에 메세지 수신자를 추가한 것이다.
메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.

메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다.

오퍼레이션이란 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세다.

오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처라고 한다.


퍼블릭 인터페이스의 품질에 영향을 미치는 원칙
 - 디미터 법칙
 - 묻지 말고 시켜라
 - 의도를 드러내는 인터페이스
 - 명령-쿼리 분리

 1. 디미터 법칙
  => 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라
  (낯선 자에게 말하지 말라! / 오직 하나의 .만 사용해라!)
  이를 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록
  프로그래밍 해야 한다. 즉, shy code를 작성하도록 하자.

 2. 묻지 말고 시켜라
 => 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스르 얻을 확률이
    높아진다.
 => 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라.
 => 이름을 더 명시적으로 가지도록 한다. 왜? 시키는 행위가 무엇인지 쉽게 알도록 하기 위해

 4. 명령-쿼리 분리 원칙
 => 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다.
 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.
 즉, 질문이 답변을 수정해서는 안된다. 라는 것이다.

    장점
      : 부수효과에 대한 부담이 없다.
      : 코드 예측이 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해진다.

 참조 투명성?
 => 어떤 표현식 e가 있을 때 모든 e를 e의 값으로 바꾸더라도 결과가
    달라지지 않는 특성

---- 9장 ----

01. 개방-폐쇄 원칙
  => 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라
  추상화를 통해서 의존성을 고정하면 새로운 기능 작성에 열려있고(개방)
  기존 코드의 수정에 대해 닫혀 있다(폐쇄)

02. 생성 사용 분리
  => 객체에 대한 생성과 사용을 분리하라!
  유연하고 재사용 가능한 설계를 원한다면 객체와 관련된
  두 가지 책임을 서로 다른 객체로 분리해야 한다.

03. 의존성 주입
  => 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후
  이를 전달해서 의존성을 해결하는 방법
  숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어뜨려 놓는다.
  의존성 주입은 이를 깔끔히 해결한다!

04. 의존성 역전 원칙
  => 객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책!
  상위 수준의 클래스가 하위 수준의 클래스에 의존하면 하위 수준의 변경에 의해 상위 수준 클래스가
  영향을 받게 된다. 의존성은 변경의 전파와 관련된 것이기 때문에 설계는 변경의 영향을
  최소화하도록 의존성을 관리해야 한다.
  => 이것의 해결사는 역시 추상화!=> 추상화에 의존하라!
  (1) 상위 수준의 모듈은 하위 수준의 모듈레 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
  (2) 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

  유연하고 재사용 가능하며 컨텟스트에 독립적인 설계는 전통적인 패러다임이 고수하는
  의존성의 방향을 역전시킨다. 전통적인 패러다임에서는 인터페이스가 하위 수준 모듈에
  속했다면 객체지향 패러다임에서는 인터페이스가 상위 수준 모듈에 속한다.

05. 유연성에 대한 조언
  유연한 설계는 유연성이 필요할 때만 옳다.
  객체를 생성하는 방법을 여러분 자신이 신경 쓰기 전에 시스템에 필요한 것(책임)들을 생각하자.

 결국, 의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설게가 유연하고
 재사용 가능해야 하기 때문이다.

 따라서 역할, 책임, 협력에 먼저 집중하라.!!!!!!

---- 10장 ----
 01. 상속과 중복 코드










